// eslint-disable-next-line @typescript-eslint/ban-ts-comment
/* @ts-nocheck */
/* eslint-disable */
import axios from 'axios'
import { Request, Response } from 'express'; import { bigQuery } from '@/App'
import fs from 'fs'
import { GraphQLClient } from 'graphql-request'
import _ from 'lodash'
import moment from 'moment'
import Web3 from 'web3'
import {
  chefAbi,
  erc20Abi,
  positionManagerAbi,
  sushiswapAbi,
  uniswapv2,
  uniswapv3,
  v3stakingAbi,
} from './abi'
import {
  appConfig,
  databaseDetails,
  lpAPRQuery,
  snowflake,
  sushiQuery,
  v2Query,
} from './config'
import { IndicesController } from './api'

const v2endpoint = 'https://api.thegraph.com/subgraphs/name/uniswap/uniswap-v2'
const uniswapv2Client = new GraphQLClient(v2endpoint)

const sushiswapEndpoint =
  'https://api.thegraph.com/subgraphs/name/sushiswap/exchange'
const sushiswapClient = new GraphQLClient(sushiswapEndpoint)

const endpoint = 'https://api.thegraph.com/subgraphs/name/uniswap/uniswap-v3'
const lpGraphQLClient = new GraphQLClient(endpoint)

export class UnusedController {
  public static indexChartDataBk = async (req: Request, res: Response) => {
    try {
      res.setHeader('Access-Control-Allow-Origin', '*')
      const iTokenAddress = req.params['iTokenAddress']

      const todaysDate = moment.utc().format('YYYY-MM-DD')
      const previousRecordDate = moment
        .utc()
        .subtract(7, 'days')
        .format('YYYY-MM-DD')

      const roiQuery = `select *, TO_DATE(DATE) as ONLY_DATE from ${databaseDetails.SCHEMA_NAME}.${databaseDetails.INDEX_ROI_DTLS_LATEST_VIEW} where ITOKEN_ADDR='${iTokenAddress}' AND ONLY_DATE >= '${previousRecordDate}' AND ONLY_DATE <= '${todaysDate}'`
      const query = `select *, TO_DATE(DATE) as ONLY_DATE from ${databaseDetails.SCHEMA_NAME}.${databaseDetails.TOKEN_ROI_DETAILS_LATEST_VIEW} WHERE ONLY_DATE >= '${previousRecordDate}' AND ONLY_DATE <= '${todaysDate}'`

      const [roiData, allData] = await Promise.all([
        snowflake.execute(roiQuery),
        snowflake.execute(query),
      ])
      if (_.isEmpty(roiData)) {
        res.send({
          status: 200,
          message: 'No records found',
          data: [],
        })
      }

      const startDate = new Date(roiData[0].DATE)
      const chartData = allData.filter((element) => {
        const compareDate = new Date(element.DATE)

        return new Date(compareDate) === new Date(startDate)
      })
      const data = chartData.map((item, i) =>
        Object.assign({}, item, roiData[i])
      )
      res.send({
        status: 200,
        data: [...allData, ...data],
      })
    } catch (error) {
      res.send({
        status: 500,
        error: error,
      })
    }
  }
  public static getTransactions = async (req: Request, res: Response) => {
    try {
      // Website you wish to allow to connect
      res.setHeader('Access-Control-Allow-Origin', '*')
      const userAddress = req.params['userAddress']
      const query = `select * from ${databaseDetails.SCHEMA_NAME}."INDICES_TRANSACTIONS_VIEW" where FROM_ADDR=${userAddress} OR TO_ADDR=${userAddress} ORDER BY CREATED_AT DESC`
      const [resp] = await bigQuery.query(query)
      res.send({
        status: 200,
        data: resp,
      })
    } catch (error) {
      res.send({
        status: 500,
        error: error,
      })
    }
  }

  public static uniswapTokenListBk = async (_req: Request, res: Response) => {
    res.setHeader('Access-Control-Allow-Origin', '*')
    let finalData: Record<string, any>[] = []

    const tokens = await axios.get('https://tokens.uniswap.org/')
    const tokenResponse = tokens.data.tokens

    if (!_.isEmpty(tokenResponse)) {
      _.forEach(tokenResponse, function (value, _key) {
        if (value.chainId === 1) {
          finalData.push({
            img: value.logoURI,
            name: value.name,
            symbol: value.symbol,
            contractAddress: value.address,
            isBaseToken: false,
            balanceLoaded: false,
          })
        }
      })
    }

    const compoundTokensList = await axios.get(
      'https://raw.githubusercontent.com/compound-finance/token-list/master/compound.tokenlist.json'
    )
    const compoundTokenResponse = compoundTokensList.data.tokens

    if (!_.isEmpty(compoundTokenResponse)) {
      _.forEach(compoundTokenResponse, function (value, _key) {
        if (value.chainId === 1) {
          const checkExist = _.find(finalData, {
            contractAddress: value.address,
          })
          if (!checkExist) {
            finalData.push({
              img: value.logoURI,
              name: value.name,
              symbol: value.symbol,
              contractAddress: value.address,
              isBaseToken: false,
              balanceLoaded: false,
            })
          }
        }
      })
    }

    const coingeckoTokensList = await axios.get(
      'https://tokens.coingecko.com/uniswap/all.json'
    )
    const coingeckoTokenResponse = coingeckoTokensList.data.tokens

    if (!_.isEmpty(coingeckoTokenResponse)) {
      _.forEach(coingeckoTokenResponse, function (value, _key) {
        if (value.chainId === 1) {
          const checkExist = _.find(finalData, {
            contractAddress: value.address,
          })
          if (!checkExist) {
            finalData.push({
              img: value.logoURI,
              name: value.name,
              symbol: value.symbol,
              contractAddress: value.address,
              isBaseToken: false,
              balanceLoaded: false,
            })
          }
        }
      })
    }

    const optimismTokensList = await axios.get(
      'https://static.optimism.io/optimism.tokenlist.json'
    )
    const optimismTokenResponse = optimismTokensList.data.tokens

    if (!_.isEmpty(optimismTokenResponse)) {
      _.forEach(optimismTokenResponse, function (value, _key) {
        if (value.chainId === 1) {
          const checkExist = _.find(finalData, {
            contractAddress: value.address,
          })
          if (!checkExist) {
            finalData.push({
              img: value.logoURI,
              name: value.name,
              symbol: value.symbol,
              contractAddress: value.address,
              isBaseToken: false,
              balanceLoaded: false,
            })
          }
        }
      })
    }

    // roll social money -

    const rollTokensList = await axios.get(
      'https://app.tryroll.com/tokens.json'
    )
    const rollTokenResponse = rollTokensList.data.tokens

    if (!_.isEmpty(rollTokenResponse)) {
      _.forEach(rollTokenResponse, function (value, _key) {
        if (value.chainId === 1) {
          const checkExist = _.find(finalData, {
            contractAddress: value.address,
          })
          if (!checkExist) {
            finalData.push({
              img: value.logoURI,
              name: value.name,
              symbol: value.symbol,
              contractAddress: value.address,
              isBaseToken: false,
              balanceLoaded: false,
            })
          }
        }
      })
    }

    if (appConfig.prod === false) {
      finalData = [
        {
          img: 'https://assets.coingecko.com/coins/images/12467/small/ghst_200.png?1600750321',
          name: 'Aavegotchi',
          symbol: 'GHST',
          contractAddress: '0x285b2291822a13E4e08dCeB4029fFD53b3B92e2b',
          isBaseToken: false,
          balanceLoaded: true,
        },
        {
          img: 'https://assets.coingecko.com/coins/images/17233/small/imx.png?1636691817',
          name: 'Immutable X',
          symbol: 'IMX',
          contractAddress: '0x380Fa2654bb8D72d05d6ca430eDA99EEA4CBbc9B',
          isBaseToken: false,
          balanceLoaded: false,
        },
        {
          img: 'https://assets.coingecko.com/coins/images/16558/small/efi-200px_%281%29.png?1624439132',
          name: 'Efinity',
          symbol: 'EFI',
          contractAddress: '0x87b6184b28C3c0b0037fFDde2c62A6d1DCfA19Dd',
          isBaseToken: false,
          balanceLoaded: false,
        },
        {
          img: 'https://assets.coingecko.com/coins/images/13574/small/NFTX_%28Real%29.jpg?1613449530',
          name: 'NFTx',
          symbol: 'NFTX',
          contractAddress: '0x84cd34139a52df39191fdd5cc26b54cbf64c1f94',
          isBaseToken: false,
          balanceLoaded: false,
        },
        {
          img: 'https://assets.coingecko.com/coins/images/12913/small/AudiusCoinLogo_2x.png?1603425727',
          name: 'Audius',
          symbol: 'AUDIO',
          contractAddress: '0x16117111eFF700746765A9EdC3ACc08B2b557e15',
          isBaseToken: false,
          balanceLoaded: false,
        },
        {
          img: 'https://assets.coingecko.com/coins/images/325/small/Tether-logo.png?1598003707',
          name: 'USDT',
          symbol: 'DRGN',
          contractAddress: '0xaBec426b9FbA9fcFCcf65aA68F4FDFc3c826dd27',
          isBaseToken: false,
          balanceLoaded: false,
        },
        {
          img: 'https://assets.coingecko.com/coins/images/12381/small/60d18e06844a844ad75901a9_mark_only_03.png?1628674771',
          name: 'Perpetual Protocol',
          symbol: 'PERP',
          contractAddress: '0x17c576524C8E478897ADA79cbf1F990ff8f2f638',
          isBaseToken: false,
          balanceLoaded: false,
        },
        {
          img: 'https://assets.coingecko.com/coins/images/13573/small/Lido_DAO.png?1609873644',
          name: 'Lido DAO',
          symbol: 'LDO',
          contractAddress: '0xdc4436137ed256EAbfBBE59472b02BC5ab85A488',
          isBaseToken: false,
          balanceLoaded: false,
        },
        {
          img: 'https://assets.coingecko.com/coins/images/3406/small/SNX.png?1598631139',
          name: 'Synthetix Network Token',
          symbol: 'SNX',
          contractAddress: '0x1A7dC0147e1Cc6ccB1984Ea3C869633A5f1efa28',
          isBaseToken: false,
          balanceLoaded: false,
        },
        {
          img: 'https://assets.coingecko.com/coins/images/15585/small/convex.png?1621256328',
          name: 'Convex Finance',
          symbol: 'CVX',
          contractAddress: '0x50F44189Ade017fDe0d6668e13c358A449b864a4',
          isBaseToken: false,
          balanceLoaded: false,
        },
        {
          img: 'https://assets.coingecko.com/coins/images/10775/small/COMP.png?1592625425',
          name: 'Compound',
          symbol: 'COMP',
          contractAddress: '0x479E330366241119068eaA9CaA948472391F06a2',
          isBaseToken: true,
          balanceLoaded: false,
        },
        {
          img: 'https://assets.coingecko.com/markets/images/576/small/2048x2048_Logo.png?1609208464',
          name: 'Sushiswap',
          symbol: 'Sushiswap',
          contractAddress: '0x1EF23620B6C9E2eabE801827C270554C97c14C15',
          isBaseToken: true,
          balanceLoaded: false,
        },
        {
          img: 'https://assets.coingecko.com/coins/images/17500/small/hjnIm9bV.jpg?1628009360',
          name: 'dYdX',
          symbol: 'DYDX',
          contractAddress: '0xF0ee31498E7F48344868F60400045551AdF6183f',
          isBaseToken: false,
          balanceLoaded: false,
        },
        {
          img: 'https://assets.coingecko.com/coins/images/15823/small/RBN_64x64.png?1633529723',
          name: 'Ribbon Finance',
          symbol: 'RBN',
          contractAddress: '0x3c356802F3E372A7BFC3Cb6899629F09Bb9A875e',
          isBaseToken: false,
          balanceLoaded: false,
        },
        {
          img: 'https://assets.coingecko.com/coins/images/12645/small/AAVE.png?1601374110',
          name: 'Aave',
          symbol: 'AAVE',
          contractAddress: '0xA5A2819E6107E01F62366eFa37bd124470c0F017',
          isBaseToken: true,
          balanceLoaded: false,
        },
        {
          img: 'https://assets.coingecko.com/coins/images/12504/small/uniswap-uni.png?1600306604',
          name: 'Uniswap',
          symbol: 'UNI',
          contractAddress: '0x2D6fEce713709b6919557C5C6C41c870FF222555',
          isBaseToken: true,
          balanceLoaded: false,
        },
        {
          img: 'https://assets.coingecko.com/coins/images/12124/small/Curve.png?1597369484',
          name: 'Curve DAO Token',
          symbol: 'CRV',
          contractAddress: '0x517A980c83fF5B77B69fFe70e4A982F2cFc06515',
          isBaseToken: false,
          balanceLoaded: false,
        },
        {
          img: 'https://assets.coingecko.com/coins/images/9956/small/4943.png?1636636734',
          name: 'Dai',
          symbol: 'DAI',
          contractAddress: '0x8651f9b88FDc4848D89eCe14b64f6A91E5875E87',
          isBaseToken: true,
          balanceLoaded: false,
        },
        {
          img: 'https://assets.coingecko.com/coins/images/14468/small/ILV.JPG?1617182121',
          name: 'Illuvium',
          symbol: 'ILV',
          contractAddress: '0x32a61e2133005cDC9867aCf8caBD1fDf4301a635',
          isBaseToken: false,
          balanceLoaded: false,
        },
        {
          img: 'https://assets.coingecko.com/coins/images/13029/small/axie_infinity_logo.png?1604471082',
          name: 'Axie Infinity',
          symbol: 'AXS',
          contractAddress: '0x1962CAb48A3b433B2843030426E5EB49413BD0Ce',
          isBaseToken: false,
          balanceLoaded: false,
        },
        {
          img: 'https://assets.coingecko.com/coins/images/12129/small/sandbox_logo.jpg?1597397942',
          name: 'The Sandbox',
          symbol: 'SAND',
          contractAddress: '0xE4dFA92F706782cE90C98779b43fCA6bb790b01F',
          isBaseToken: false,
          balanceLoaded: false,
        },
        {
          img: 'https://assets.coingecko.com/coins/images/1102/small/enjin-coin-logo.png?1547035078',
          name: 'Enjin Coin',
          symbol: 'ENJ',
          contractAddress: '0x1aDcdBc08Dc825D3c396E613D5320aa2d38290a8',
          isBaseToken: false,
          balanceLoaded: false,
        },
        {
          img: 'https://assets.coingecko.com/coins/images/4713/small/matic-token-icon.png?1624446912',
          name: 'Polygon',
          symbol: 'MATIC',
          contractAddress: '0x7Eec234AB0De22C973d1c43e3AE0d5d3f2203898',
          isBaseToken: false,
          balanceLoaded: false,
        },
        {
          img: 'https://assets.coingecko.com/coins/images/878/small/decentraland-mana.png?1550108745',
          name: 'Decentraland',
          symbol: 'MANA',
          contractAddress: '0x6c408a730c53Ec73aC4E0a296172E5fc3Adb42ca',
          isBaseToken: false,
          balanceLoaded: false,
        },
        {
          img: 'https://assets.coingecko.com/coins/images/325/small/Tether-logo.png?1598003707',
          name: 'Tether',
          symbol: 'USDT',
          contractAddress: '0xaBec426b9FbA9fcFCcf65aA68F4FDFc3c826dd27',
          isBaseToken: true,
          balanceLoaded: false,
        },
        {
          img: 'https://assets.coingecko.com/coins/images/877/small/chainlink-new-logo.png?1547034700',
          name: 'Chainlink',
          symbol: 'LINK',
          contractAddress: '0xF2321a1abfb67920A8971CD1296D11f4f220ac49',
          isBaseToken: false,
          balanceLoaded: false,
        },
        {
          img: 'https://assets.coingecko.com/coins/images/4713/small/matic-token-icon.png?1624446912',
          name: 'Polygon',
          symbol: 'MATIC',
          contractAddress: '0x7Eec234AB0De22C973d1c43e3AE0d5d3f2203898',
          isBaseToken: false,
          balanceLoaded: false,
        },
        {
          img: 'https://assets.coingecko.com/coins/images/646/small/pL1VuXm.png?1604543202',
          name: 'iExec RLC',
          symbol: 'RLC',
          contractAddress: '0x1729E938Ae3243877931AB54915bf7AE0260DaF4',
          isBaseToken: false,
          balanceLoaded: false,
        },
        {
          img: 'https://assets.coingecko.com/coins/images/11636/small/rndr.png?1638840934',
          name: 'Render Token',
          symbol: 'RNDR',
          contractAddress: '0xC4f3a55B09D0293711E1356FDbCf1508F762FF30',
          isBaseToken: false,
          balanceLoaded: false,
        },
        {
          img: 'https://assets.coingecko.com/coins/images/9956/small/4943.png?1636636734',
          name: 'Dai',
          symbol: 'DAI',
          contractAddress: '0x8651f9b88FDc4848D89eCe14b64f6A91E5875E87',
          isBaseToken: false,
          balanceLoaded: false,
        },
        {
          img: 'https://assets.coingecko.com/nft_contracts/images/275/small/the-repus-nft.gif?1645460271',
          name: 'EPNS',
          symbol: 'EPNS',
          contractAddress: '0xB6aEF9906c4e25fe168446cf4eE995F9ADe6c659',
          isBaseToken: false,
          balanceLoaded: false,
        },
        {
          img: '',
          name: 'ASTRA',
          symbol: 'ASTRA',
          contractAddress: '0x5b22C8e7855e9Fa7359467d275CfFA35bF1409BF',
          isBaseToken: false,
          balanceLoaded: false,
        },
        {
          img: '',
          name: 'USDC',
          symbol: 'USDC',
          contractAddress: '0x4D00AdC2A8Bc5bbe3321533e0fb56636b6B2460b',
          isBaseToken: false,
          balanceLoaded: false,
        },
        {
          img: '',
          name: 'USDT',
          symbol: 'USDT',
          contractAddress: '0x0036D26aC85053400B51997B339Be8bd08e173C0',
          isBaseToken: false,
          balanceLoaded: false,
        },
        {
          img: '',
          name: 'DAI',
          symbol: 'DAI',
          contractAddress: '0xc6196e00Fd2970BD91777AADd387E08574cDf92a',
          isBaseToken: false,
          balanceLoaded: false,
        },
      ]
    }

    res.send({
      status: 200,
      data: finalData,
    })
  }

  public static updateTokenListJson = async () => {
    let finalData: Record<string, any>[] = []

    if (appConfig.prod === true) {
      finalData.push({
        img: '',
        name: 'ASTRA',
        symbol: 'ASTRA',
        contractAddress: appConfig.astraContractAddress,
        isBaseToken: false,
        balanceLoaded: false,
      })
    }

    const tokens = await axios.get('https://tokens.uniswap.org/')
    const tokenResponse = tokens.data.tokens

    if (!_.isEmpty(tokenResponse)) {
      _.forEach(tokenResponse, function (value, _key) {
        if (value.chainId === 1) {
          finalData.push({
            img: value.logoURI,
            name: value.name,
            symbol: value.symbol,
            contractAddress: _.toLower(value.address),
            isBaseToken: false,
            balanceLoaded: false,
          })
        }
      })
    }

    const compoundTokensList = await axios.get(
      'https://raw.githubusercontent.com/compound-finance/token-list/master/compound.tokenlist.json'
    )
    const compoundTokenResponse = compoundTokensList.data.tokens

    if (!_.isEmpty(compoundTokenResponse)) {
      _.forEach(compoundTokenResponse, function (value, _key) {
        if (value.chainId === 1) {
          const checkExist = _.find(finalData, {
            contractAddress: _.toLower(value.address),
          })
          if (!checkExist) {
            finalData.push({
              img: value.logoURI,
              name: value.name,
              symbol: value.symbol,
              contractAddress: _.toLower(value.address),
              isBaseToken: false,
              balanceLoaded: false,
            })
          }
        }
      })
    }

    const coingeckoTokensList = await axios.get(
      'https://tokens.coingecko.com/uniswap/all.json'
    )
    const coingeckoTokenResponse = coingeckoTokensList.data.tokens

    if (!_.isEmpty(coingeckoTokenResponse)) {
      _.forEach(coingeckoTokenResponse, function (value, _key) {
        if (value.chainId === 1) {
          const checkExist = _.find(finalData, {
            contractAddress: _.toLower(value.address),
          })
          if (!checkExist) {
            finalData.push({
              img: value.logoURI,
              name: value.name,
              symbol: value.symbol,
              contractAddress: _.toLower(value.address),
              isBaseToken: false,
              balanceLoaded: false,
            })
          }
        }
      })
    }

    const optimismTokensList = await axios.get(
      'https://static.optimism.io/optimism.tokenlist.json'
    )
    const optimismTokenResponse = optimismTokensList.data.tokens

    if (!_.isEmpty(optimismTokenResponse)) {
      _.forEach(optimismTokenResponse, function (value, _key) {
        if (value.chainId === 1) {
          const checkExist = _.find(finalData, {
            contractAddress: _.toLower(value.address),
          })
          if (!checkExist) {
            finalData.push({
              img: value.logoURI,
              name: value.name,
              symbol: value.symbol,
              contractAddress: _.toLower(value.address),
              isBaseToken: false,
              balanceLoaded: false,
            })
          }
        }
      })
    }

    // roll social money -

    const rollTokensList = await axios.get(
      'https://app.tryroll.com/tokens.json'
    )
    const rollTokenResponse = rollTokensList.data.tokens

    if (!_.isEmpty(rollTokenResponse)) {
      _.forEach(rollTokenResponse, function (value, _key) {
        if (value.chainId === 1) {
          const checkExist = _.find(finalData, {
            contractAddress: _.toLower(value.address),
          })
          if (!checkExist) {
            finalData.push({
              img: value.logoURI,
              name: value.name,
              symbol: value.symbol,
              contractAddress: _.toLower(value.address),
              isBaseToken: false,
              balanceLoaded: false,
            })
          }
        }
      })
    }

    if (appConfig.prod === false) {
      finalData = [
        {
          img: 'https://assets.coingecko.com/coins/images/12467/small/ghst_200.png?1600750321',
          name: 'Aavegotchi',
          symbol: 'GHST',
          contractAddress: '0x285b2291822a13E4e08dCeB4029fFD53b3B92e2b',
          isBaseToken: false,
          balanceLoaded: true,
        },
        {
          img: 'https://assets.coingecko.com/coins/images/17233/small/imx.png?1636691817',
          name: 'Immutable X',
          symbol: 'IMX',
          contractAddress: '0x380Fa2654bb8D72d05d6ca430eDA99EEA4CBbc9B',
          isBaseToken: false,
          balanceLoaded: false,
        },
        {
          img: 'https://assets.coingecko.com/coins/images/16558/small/efi-200px_%281%29.png?1624439132',
          name: 'Efinity',
          symbol: 'EFI',
          contractAddress: '0x87b6184b28C3c0b0037fFDde2c62A6d1DCfA19Dd',
          isBaseToken: false,
          balanceLoaded: false,
        },
        {
          img: 'https://assets.coingecko.com/coins/images/13574/small/NFTX_%28Real%29.jpg?1613449530',
          name: 'NFTx',
          symbol: 'NFTX',
          contractAddress: '0x84cd34139a52df39191fdd5cc26b54cbf64c1f94',
          isBaseToken: false,
          balanceLoaded: false,
        },
        {
          img: 'https://assets.coingecko.com/coins/images/12913/small/AudiusCoinLogo_2x.png?1603425727',
          name: 'Audius',
          symbol: 'AUDIO',
          contractAddress: '0x16117111eFF700746765A9EdC3ACc08B2b557e15',
          isBaseToken: false,
          balanceLoaded: false,
        },
        {
          img: 'https://assets.coingecko.com/coins/images/325/small/Tether-logo.png?1598003707',
          name: 'USDT',
          symbol: 'DRGN',
          contractAddress: '0xaBec426b9FbA9fcFCcf65aA68F4FDFc3c826dd27',
          isBaseToken: false,
          balanceLoaded: false,
        },
        {
          img: 'https://assets.coingecko.com/coins/images/12381/small/60d18e06844a844ad75901a9_mark_only_03.png?1628674771',
          name: 'Perpetual Protocol',
          symbol: 'PERP',
          contractAddress: '0x17c576524C8E478897ADA79cbf1F990ff8f2f638',
          isBaseToken: false,
          balanceLoaded: false,
        },
        {
          img: 'https://assets.coingecko.com/coins/images/13573/small/Lido_DAO.png?1609873644',
          name: 'Lido DAO',
          symbol: 'LDO',
          contractAddress: '0xdc4436137ed256EAbfBBE59472b02BC5ab85A488',
          isBaseToken: false,
          balanceLoaded: false,
        },
        {
          img: 'https://assets.coingecko.com/coins/images/3406/small/SNX.png?1598631139',
          name: 'Synthetix Network Token',
          symbol: 'SNX',
          contractAddress: '0x1A7dC0147e1Cc6ccB1984Ea3C869633A5f1efa28',
          isBaseToken: false,
          balanceLoaded: false,
        },
        {
          img: 'https://assets.coingecko.com/coins/images/15585/small/convex.png?1621256328',
          name: 'Convex Finance',
          symbol: 'CVX',
          contractAddress: '0x50F44189Ade017fDe0d6668e13c358A449b864a4',
          isBaseToken: false,
          balanceLoaded: false,
        },
        {
          img: 'https://assets.coingecko.com/coins/images/10775/small/COMP.png?1592625425',
          name: 'Compound',
          symbol: 'COMP',
          contractAddress: '0x479E330366241119068eaA9CaA948472391F06a2',
          isBaseToken: true,
          balanceLoaded: false,
        },
        {
          img: 'https://assets.coingecko.com/markets/images/576/small/2048x2048_Logo.png?1609208464',
          name: 'Sushiswap',
          symbol: 'Sushiswap',
          contractAddress: '0x1EF23620B6C9E2eabE801827C270554C97c14C15',
          isBaseToken: true,
          balanceLoaded: false,
        },
        {
          img: 'https://assets.coingecko.com/coins/images/17500/small/hjnIm9bV.jpg?1628009360',
          name: 'dYdX',
          symbol: 'DYDX',
          contractAddress: '0xF0ee31498E7F48344868F60400045551AdF6183f',
          isBaseToken: false,
          balanceLoaded: false,
        },
        {
          img: 'https://assets.coingecko.com/coins/images/15823/small/RBN_64x64.png?1633529723',
          name: 'Ribbon Finance',
          symbol: 'RBN',
          contractAddress: '0x3c356802F3E372A7BFC3Cb6899629F09Bb9A875e',
          isBaseToken: false,
          balanceLoaded: false,
        },
        {
          img: 'https://assets.coingecko.com/coins/images/12645/small/AAVE.png?1601374110',
          name: 'Aave',
          symbol: 'AAVE',
          contractAddress: '0xA5A2819E6107E01F62366eFa37bd124470c0F017',
          isBaseToken: true,
          balanceLoaded: false,
        },
        {
          img: 'https://assets.coingecko.com/coins/images/12504/small/uniswap-uni.png?1600306604',
          name: 'Uniswap',
          symbol: 'UNI',
          contractAddress: '0x2D6fEce713709b6919557C5C6C41c870FF222555',
          isBaseToken: true,
          balanceLoaded: false,
        },
        {
          img: 'https://assets.coingecko.com/coins/images/12124/small/Curve.png?1597369484',
          name: 'Curve DAO Token',
          symbol: 'CRV',
          contractAddress: '0x517A980c83fF5B77B69fFe70e4A982F2cFc06515',
          isBaseToken: false,
          balanceLoaded: false,
        },
        {
          img: 'https://assets.coingecko.com/coins/images/9956/small/4943.png?1636636734',
          name: 'Dai',
          symbol: 'DAI',
          contractAddress: '0x8651f9b88FDc4848D89eCe14b64f6A91E5875E87',
          isBaseToken: true,
          balanceLoaded: false,
        },
        {
          img: 'https://assets.coingecko.com/coins/images/14468/small/ILV.JPG?1617182121',
          name: 'Illuvium',
          symbol: 'ILV',
          contractAddress: '0x32a61e2133005cDC9867aCf8caBD1fDf4301a635',
          isBaseToken: false,
          balanceLoaded: false,
        },
        {
          img: 'https://assets.coingecko.com/coins/images/13029/small/axie_infinity_logo.png?1604471082',
          name: 'Axie Infinity',
          symbol: 'AXS',
          contractAddress: '0x1962CAb48A3b433B2843030426E5EB49413BD0Ce',
          isBaseToken: false,
          balanceLoaded: false,
        },
        {
          img: 'https://assets.coingecko.com/coins/images/12129/small/sandbox_logo.jpg?1597397942',
          name: 'The Sandbox',
          symbol: 'SAND',
          contractAddress: '0xE4dFA92F706782cE90C98779b43fCA6bb790b01F',
          isBaseToken: false,
          balanceLoaded: false,
        },
        {
          img: 'https://assets.coingecko.com/coins/images/1102/small/enjin-coin-logo.png?1547035078',
          name: 'Enjin Coin',
          symbol: 'ENJ',
          contractAddress: '0x1aDcdBc08Dc825D3c396E613D5320aa2d38290a8',
          isBaseToken: false,
          balanceLoaded: false,
        },
        {
          img: 'https://assets.coingecko.com/coins/images/4713/small/matic-token-icon.png?1624446912',
          name: 'Polygon',
          symbol: 'MATIC',
          contractAddress: '0x7Eec234AB0De22C973d1c43e3AE0d5d3f2203898',
          isBaseToken: false,
          balanceLoaded: false,
        },
        {
          img: 'https://assets.coingecko.com/coins/images/878/small/decentraland-mana.png?1550108745',
          name: 'Decentraland',
          symbol: 'MANA',
          contractAddress: '0x6c408a730c53Ec73aC4E0a296172E5fc3Adb42ca',
          isBaseToken: false,
          balanceLoaded: false,
        },
        {
          img: 'https://assets.coingecko.com/coins/images/325/small/Tether-logo.png?1598003707',
          name: 'Tether',
          symbol: 'USDT',
          contractAddress: '0xaBec426b9FbA9fcFCcf65aA68F4FDFc3c826dd27',
          isBaseToken: true,
          balanceLoaded: false,
        },
        {
          img: 'https://assets.coingecko.com/coins/images/877/small/chainlink-new-logo.png?1547034700',
          name: 'Chainlink',
          symbol: 'LINK',
          contractAddress: '0xF2321a1abfb67920A8971CD1296D11f4f220ac49',
          isBaseToken: false,
          balanceLoaded: false,
        },
        {
          img: 'https://assets.coingecko.com/coins/images/4713/small/matic-token-icon.png?1624446912',
          name: 'Polygon',
          symbol: 'MATIC',
          contractAddress: '0x7Eec234AB0De22C973d1c43e3AE0d5d3f2203898',
          isBaseToken: false,
          balanceLoaded: false,
        },
        {
          img: 'https://assets.coingecko.com/coins/images/646/small/pL1VuXm.png?1604543202',
          name: 'iExec RLC',
          symbol: 'RLC',
          contractAddress: '0x1729E938Ae3243877931AB54915bf7AE0260DaF4',
          isBaseToken: false,
          balanceLoaded: false,
        },
        {
          img: 'https://assets.coingecko.com/coins/images/11636/small/rndr.png?1638840934',
          name: 'Render Token',
          symbol: 'RNDR',
          contractAddress: '0xC4f3a55B09D0293711E1356FDbCf1508F762FF30',
          isBaseToken: false,
          balanceLoaded: false,
        },
        {
          img: 'https://assets.coingecko.com/coins/images/9956/small/4943.png?1636636734',
          name: 'Dai',
          symbol: 'DAI',
          contractAddress: '0x8651f9b88FDc4848D89eCe14b64f6A91E5875E87',
          isBaseToken: false,
          balanceLoaded: false,
        },
        {
          img: 'https://assets.coingecko.com/nft_contracts/images/275/small/the-repus-nft.gif?1645460271',
          name: 'EPNS',
          symbol: 'EPNS',
          contractAddress: '0xB6aEF9906c4e25fe168446cf4eE995F9ADe6c659',
          isBaseToken: false,
          balanceLoaded: false,
        },
        {
          img: '',
          name: 'ASTRA',
          symbol: 'ASTRA',
          contractAddress: '0x5b22C8e7855e9Fa7359467d275CfFA35bF1409BF',
          isBaseToken: false,
          balanceLoaded: false,
        },
        {
          img: '',
          name: 'USDC',
          symbol: 'USDC',
          contractAddress: '0x4D00AdC2A8Bc5bbe3321533e0fb56636b6B2460b',
          isBaseToken: false,
          balanceLoaded: false,
        },
        {
          img: '',
          name: 'USDT',
          symbol: 'USDT',
          contractAddress: '0x0036D26aC85053400B51997B339Be8bd08e173C0',
          isBaseToken: false,
          balanceLoaded: false,
        },
        {
          img: '',
          name: 'DAI',
          symbol: 'DAI',
          contractAddress: '0xc6196e00Fd2970BD91777AADd387E08574cDf92a',
          isBaseToken: false,
          balanceLoaded: false,
        },
      ]
    }

    const jsonData = JSON.stringify(finalData)
    fs.writeFileSync('public/tokens.json', jsonData)
  }

  public static updateProposalEndTime = async () => {
    const finalData: Record<string, any> = {}
    // const queryBk = `select A.*, B.* from ${databaseDetails.SCHEMA_NAME}."PROPOSAL_DETAILS_LATEST_VIEW" A RIGHT JOIN ${databaseDetails.SCHEMA_NAME}."PROPOSAL_CREATED_VIEW" B ON A.ID = B.ID`

    try {
      const httpProviderUrl = appConfig.prod
        ? `${appConfig.infuraBaseURL}${appConfig.infuraToken}`
        : `${appConfig.infuraBaseURL}`
      const web3 = new Web3(new Web3.providers.HttpProvider(httpProviderUrl))
      const currentBlockNumber = await web3.eth.getBlockNumber()
      if (!currentBlockNumber) {
        return
      }
      const query = `SELECT * FROM ${databaseDetails.SCHEMA_NAME}.PROPOSAL_CREATED_DETAILS WHERE ENDBLOCK > ${currentBlockNumber}`
      const proposals = await snowflake.execute(query)
      const fileData: Record<string, any> = JSON.parse(
        fs
          .readFileSync(`${appConfig.jsonFilepathInitials}proposalblocks.json`)
          .toString()
      )
      // const fileData = JSON.parse(jsonData)

      _.forEach(proposals, async function (value, _key) {
        if (fileData[value.ID]) {
          return
        }
        const compoundTokensList = await axios.get(
          `${appConfig.explorerAPIUrl}?module=block&action=getblockcountdown&blockno=${value.ENDBLOCK}`
        )
        const duration =
          compoundTokensList.data && compoundTokensList.data.result
            ? compoundTokensList.data.result.EstimateTimeInSec
            : ''
        if (duration) {
          const endDate = moment()
            .second(duration)
            .utc()
            .format('DD MMM YYYY HH:mm A')
          finalData[value.ID] = endDate
        }
        const jsonData = JSON.stringify(finalData)
        fs.writeFileSync(
          `${appConfig.jsonFilepathInitials}proposalblocks.json`,
          jsonData
        )
      })
    } catch (err) {
      /* console.log('err', err); */
    }
  }

  public static updateAPRFileBk = async () => {
    try {
      const blocks_per_day = appConfig.blocksPerDay
      const astraTokenDetails = await axios.get(
        `https://api.coingecko.com/api/v3/simple/price?ids=astra-dao&vs_currencies=USD`
      )
      let tokenPrice =
        astraTokenDetails && astraTokenDetails.data
          ? astraTokenDetails.data['astra-dao'].usd
          : ''
      tokenPrice = parseFloat(tokenPrice).toFixed(10)

      const httpProviderUrl = appConfig.prod
        ? `${appConfig.infuraBaseURL}${appConfig.infuraToken}`
        : `${appConfig.infuraBaseURL}`
      const web3 = new Web3(new Web3.providers.HttpProvider(httpProviderUrl))

      const contract = new web3.eth.Contract(
        v3stakingAbi,
        appConfig.v3StakingContract
      )
      const astraPerBlock = await contract.methods.astraPerBlock().call()
      // astraPerBlock = Web3.utils.fromWei(astraPerBlock, "ether")
      // ? Number(astraPerBlock) / Math.pow(10, 18)
      // : ''
      const ASTRA_Token_Price = tokenPrice
      const ASTRA_Per_Day =
        Number(Web3.utils.fromWei(astraPerBlock, 'ether')) * blocks_per_day

      let liquidityMiningPercentage: any = ''

      const lmContract = new web3.eth.Contract(
        positionManagerAbi,
        appConfig.nftContractAddress
      )

      const balance = await lmContract.methods
        .balanceOf(appConfig.v3StakingContract)
        .call()

      let totalAstra = 0
      let totalWeth = 0
      const object = new IndicesController()

      for (let i = 0; i < Number(balance); i++) {
        const tokenId = await lmContract.methods
          .tokenOfOwnerByIndex(appConfig.v3StakingContract, i)
          .call()
        const positionData: any = await object.getDepositedAmount(tokenId)
        totalAstra = totalAstra + parseInt(positionData.astraAmount)
        totalWeth = totalWeth + parseInt(positionData.wethAmount)
      }
      // ether price from coingecko

      const ethPrice = await axios.get(
        'https://api.coingecko.com/api/v3/simple/price?ids=ethereum&vs_currencies=USD'
      )
      const coingeckoTokenResponse = ethPrice.data
      const ethereumPrice = coingeckoTokenResponse
        ? coingeckoTokenResponse.ethereum.usd
        : ''

      const liquidityMiningStaking =
        totalAstra * ASTRA_Token_Price + totalWeth * ethereumPrice
      liquidityMiningPercentage =
        100 *
        ((ASTRA_Token_Price * ASTRA_Per_Day) / liquidityMiningStaking) *
        365
      liquidityMiningPercentage = liquidityMiningPercentage.toFixed(2)
      // ASTRA <-> APR

      const astraContract = new web3.eth.Contract(
        chefAbi,
        appConfig.chefContract
      )
      const chefAstraPerBlock = Number(
        Web3.utils.fromWei(
          await astraContract.methods.astraPerBlock().call(),
          'ether'
        )
      )
      // chefAstraPerBlock = chefAstraPerBlock
      //   ? Number(chefAstraPerBlock) / Math.pow(10, 18)
      //   : ''

      const CHEF_ASTRA_Per_Day = chefAstraPerBlock * blocks_per_day

      /** Total Deposit counter */
      const chefDepositEvents = await astraContract.getPastEvents('Deposit', {
        fromBlock: appConfig.astrastakingStartBlockPhase2,
        toBlock: 'latest',
      })
      const chefDepositEventCounter = _.size(chefDepositEvents)
      let totalChefDepositCounter: any = 0
      if (chefDepositEventCounter > 0) {
        for (let i = 1; i <= chefDepositEventCounter; i++) {
          try {
            console.log('chefDepositEvents[i - 1]', chefDepositEvents[i - 1])
            const eventLog = chefDepositEvents[i - 1]
            const eventVerifyData =
              eventLog && typeof eventLog !== 'string' && eventLog.returnValues
                ? eventLog.returnValues
                : {}
            console.log('eventVerifyData', eventVerifyData)
            const tokens =
              eventVerifyData && eventVerifyData.amount
                ? Number(eventVerifyData.amount) / Math.pow(10, 18)
                : ''
            totalChefDepositCounter += tokens
          } catch (err) {
            console.log('for loop error block', err)
          }
        }
      }
      /** Total Deposit counter ends */

      /** Total withdrawal counter */

      const chefWithdrawEvents = await contract.getPastEvents('Withdraw', {
        fromBlock: appConfig.astrastakingStartBlockPhase2,
        toBlock: 'latest',
      })
      const chefWithdrawEventCounter = _.size(chefWithdrawEvents)
      let chefTotalWithdrawCounter: any = 0
      if (chefWithdrawEventCounter > 0) {
        for (let i = 1; i <= chefWithdrawEventCounter; i++) {
          try {
            const eventLog = chefWithdrawEvents[i - 1]
            const eventVerifyData =
              eventLog && typeof eventLog !== 'string' && eventLog.returnValues
                ? eventLog.returnValues
                : {}
            const tokens =
              eventVerifyData && eventVerifyData.amount
                ? Number(eventVerifyData.amount) / Math.pow(10, 18)
                : ''
            chefTotalWithdrawCounter += tokens
          } catch (err) {
            console.log('for loop error block', err)
          }
        }
      }

      /** Total withdrawal counter */
      let astraStaking =
        parseFloat(totalChefDepositCounter) -
        parseFloat(chefTotalWithdrawCounter)
      const astraStakingAmount = astraStaking
      astraStaking = astraStaking * ASTRA_Token_Price

      const astraMiningPercentage = (
        100 *
        ((ASTRA_Token_Price * CHEF_ASTRA_Per_Day) / astraStaking) *
        365
      ).toFixed(2)

      const finalData = {
        liquidityMiningAPR: liquidityMiningPercentage,
        stakingRewardsAPR: astraMiningPercentage,
        astraStakingAmount,
      }
      const jsonData = JSON.stringify(finalData)
      fs.writeFileSync(
        `${appConfig.jsonFilepathInitials}aprdetails.json`,
        jsonData
      )
    } catch (err) {
      console.log('err', err)
    }
  }

  public static prepareuniswapv3PairAddresses = async () => {
    const factoryAddress = '0x1F98431c8aD98523631AE4a59f267346ea31F984'
    const usdcAddress = '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48'

    const web3 = new Web3(
      new Web3.providers.HttpProvider(
        `${appConfig.infuraBaseURL}${appConfig.infuraToken}`
      )
    )

    const contract = new web3.eth.Contract(uniswapv3, factoryAddress)
    // const usdcInstance = new web3.eth.Contract(erc20Abi, usdcAddress);

    const jsonData = require('../../public/tokens.json')
    console.log('Prepare Pair Address Start Time Moment', moment())

    const chunkData = _.chunk(jsonData, 300)
    const processArray = chunkData[14]

    let pairListAddresses = {}

    const pairAddressData = require('../../public/v3pairAddresses.json')

    if (pairAddressData) {
      pairListAddresses = pairAddressData
    }

    // const object = new IndicesController();
    /* const reponsestatus =  */ await Promise.all(
      processArray.map(async (value) => {
        let pairAddress = await contract.methods
          .getPool(value.contractAddress, usdcAddress, 3000)
          .call()
        pairAddress = _.toLower(pairAddress)
        console.log('pairAddress', value.symbol, pairAddress)
        pairListAddresses[value.contractAddress] = pairAddress
        const jsonWriteData = JSON.stringify(pairListAddresses)
        fs.writeFileSync('public/v3pairAddresses.json', jsonWriteData)
        await new Promise((resolve) => setTimeout(resolve, 10))
        return value
      })
    )
    console.log('process ended moment', moment())
  }

  public static prepareuniswapv2PairAddresses = async () => {
    const factoryAddress = '0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f'
    const usdcAddress = '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48'

    const web3 = new Web3(
      new Web3.providers.HttpProvider(
        `${appConfig.infuraBaseURL}${appConfig.infuraToken}`
      )
    )

    const contract = new web3.eth.Contract(uniswapv2, factoryAddress)

    const jsonData = require('../../public/tokens.json')
    console.log('Prepare Pair Address Start Time Moment', moment())

    const chunkData = _.chunk(jsonData, 350)
    const processArray = chunkData[12]

    let pairListAddresses = {}

    const pairAddressData = require('../../public/v2pairAddresses.json')

    if (pairAddressData) {
      pairListAddresses = pairAddressData
    }

    // const object = new IndicesController();
    /* const reponsestatus =  */ await Promise.all(
      processArray.map(async (value) => {
        let pairAddress = await contract.methods
          .getPair(value.contractAddress, usdcAddress)
          .call()
        pairAddress = _.toLower(pairAddress)
        console.log('pairAddress', value.symbol, pairAddress)
        pairListAddresses[value.contractAddress] = pairAddress
        const jsonWriteData = JSON.stringify(pairListAddresses)
        fs.writeFileSync('public/v2pairAddresses.json', jsonWriteData)
        await new Promise((resolve) => setTimeout(resolve, 10))
        return value
      })
    )
    console.log('process ended moment', moment())
  }

  public static preparesushiswapPairAddresses = async () => {
    const factoryAddress = '0xC0AEe478e3658e2610c5F7A4A2E1777cE9e4f2Ac'
    const usdcAddress = '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48'

    const web3 = new Web3(
      new Web3.providers.HttpProvider(
        `${appConfig.infuraBaseURL}${appConfig.infuraToken}`
      )
    )

    const contract = new web3.eth.Contract(sushiswapAbi, factoryAddress)

    const jsonData = require('../../public/tokens.json')
    console.log('Prepare Pair Address Start Time Moment', moment())

    const chunkData = _.chunk(jsonData, 350)
    const processArray = chunkData[12]

    let pairListAddresses = {}

    const pairAddressData = require('../../public/sushiswapPairAddresses.json')

    if (pairAddressData) {
      pairListAddresses = pairAddressData
    }

    // const object = new IndicesController();
    /* const reponsestatus =  */ await Promise.all(
      processArray.map(async (value) => {
        let pairAddress = await contract.methods
          .getPair(value.contractAddress, usdcAddress)
          .call()
        pairAddress = _.toLower(pairAddress)
        console.log('pairAddress', value.symbol, pairAddress)
        pairListAddresses[value.contractAddress] = pairAddress
        const jsonWriteData = JSON.stringify(pairListAddresses)
        fs.writeFileSync('public/sushiswapPairAddresses.json', jsonWriteData)
        await new Promise((resolve) => setTimeout(resolve, 10))
        return value
      })
    )
    console.log('process ended moment', moment())
  }

  public static prepareUSDCValidatedTokenData = async () => {
    /*  const factoryAddress = "0x1F98431c8aD98523631AE4a59f267346ea31F984";
    const usdcAddress = "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48"; */

    /* const web3 = new Web3(
      new Web3.providers.HttpProvider(
       `${appConfig.infuraBaseURL}${appConfig.infuraToken}`
      )
    ); */

    // var contract = new Contract(contractAbi, factoryAddress);
    // var usdcInstance = new Contract(erc20Abi, usdcAddress);

    // const contract = await new web3.eth.Contract(uniswapv3, factoryAddress);
    // const usdcInstance = await new web3.eth.Contract(erc20Abi, usdcAddress);

    const jsonData = require('../../public/tokens.json')

    const v3pairsData = require('../../public/v3pairAddresses.json')
    const v2pairsData = require('../../public/v2pairAddresses.json')
    const sushiswapPairData = require('../../public/sushiswapPairAddresses.json')

    // const _this = this;

    const approvedTokenList = []
    const object = new IndicesController()

    //get WETH price
    const wethPrice = await axios.get(
      'https://api.coingecko.com/api/v3/simple/price?ids=weth&vs_currencies=usd'
    )
    const wethPriceData: any = wethPrice.data.data
    const wethPriceUsd: any =
      wethPriceData && wethPriceData.weth ? wethPriceData.weth.usd : 0

    /* const reponsestatus =  */ await Promise.all(
      jsonData.map(async (value, _key) => {
        /** checking if uniswap v3 method is having data */
        if (
          v3pairsData[value.contractAddress] &&
          v3pairsData[value.contractAddress] !==
            '0x0000000000000000000000000000000000000000'
        ) {
          const checkExist = _.find(approvedTokenList, {
            contractAddress: value.address,
          })

          if (checkExist) {
            return
          }

          const checkUniswapv3 = await object.checkUniswapV3(
            v3pairsData[value.contractAddress],
            value,
            wethPriceUsd
          )

          if (
            _.isObject(checkUniswapv3) &&
            checkUniswapv3.status === true &&
            !checkExist
          ) {
            value.exchange = 'Uniswap v3'
            value.pairAddress = checkUniswapv3.pairAddress
            value.usdcBalance = checkUniswapv3.usdcBalance
            approvedTokenList.push(value)
          }
        }
        /** checking if uniswap v3 method is having data ends */

        /** checking if uniswap v2 method is having data */
        if (
          v2pairsData[value.contractAddress] &&
          v2pairsData[value.contractAddress] !==
            '0x0000000000000000000000000000000000000000'
        ) {
          const checkExistv2 = _.find(approvedTokenList, {
            contractAddress: value.address,
          })

          if (checkExistv2) {
            return
          }

          const checkUniswapv2 = await object.checkUniswapV2(
            v2pairsData[value.contractAddress]
          )

          if (
            _.isObject(checkUniswapv2) &&
            checkUniswapv2.status === true &&
            !checkExistv2
          ) {
            value.exchange = 'Uniswap v2'
            value.pairAddress = checkUniswapv2.pairAddress
            value.usdcBalance = checkUniswapv2.usdcBalance
            approvedTokenList.push(value)
          }
        }
        /** checking if uniswap v2 method is having data ends */

        /** checking if sushiswap method is having data */
        if (
          sushiswapPairData[value.contractAddress] &&
          sushiswapPairData[value.contractAddress] !==
            '0x0000000000000000000000000000000000000000'
        ) {
          const checkExistSushi = _.find(approvedTokenList, {
            contractAddress: value.address,
          })

          if (checkExistSushi) {
            return
          }

          const checkSushiswap = await object.checkSushiswap(
            sushiswapPairData[value.contractAddress]
          )

          if (
            _.isObject(checkSushiswap) &&
            checkSushiswap.status === true &&
            !checkExistSushi
          ) {
            value.exchange = 'Sushiswap'
            value.pairAddress = checkSushiswap.pairAddress
            value.usdcBalance = checkSushiswap.usdcBalance
            approvedTokenList.push(value)
          }
        }
        /** checking if sushiswap method is having data ends */

        /*  console.log(value.symbol);
        const checkUniswapv3 = await object.checkUniswapV3(
          usdcAddress,
          factoryAddress,
          value
        );
        if (checkUniswapv3) {
          approvedTokenList.push(value);
          return;
        } */
        await new Promise((resolve) => setTimeout(resolve, 20))
        return value
      })
    )

    console.log('approvedTokenList', approvedTokenList)
    console.log('moment', moment())

    console.log('total number of tokens', _.size(approvedTokenList))

    const jsonWriteData = JSON.stringify(approvedTokenList)
    fs.writeFileSync('public/finalTokens.json', jsonWriteData)
  }

  public checkUniswapV3 = async (
    pairAddress,
    _value,
    wethPriceUsd: any = 0
  ) => {
    try {
      const responseObject = {
        status: false,
        pairAddress: '',
        usdcBalance: 0,
        wethBalance: 0,
      }
      const usdcAddress = appConfig.usdcAddress
      const web3 = new Web3(
        new Web3.providers.HttpProvider(
          `${appConfig.infuraBaseURL}${appConfig.infuraToken}`
        )
      )

      const wethContractInstance = new web3.eth.Contract(
        erc20Abi,
        appConfig.wethAddress
      )
      const wethBalance =
        (await wethContractInstance.methods.balanceOf(pairAddress).call()) /
        1000000000000000000
      const wethValuation = wethBalance * wethPriceUsd

      if (wethValuation > appConfig.minimumUSDCApprovalAmount) {
        responseObject.status = true
        responseObject.pairAddress = pairAddress
        responseObject.usdcBalance = wethValuation
        return responseObject
      } else {
        const usdcInstance = new web3.eth.Contract(erc20Abi, usdcAddress)
        const usdcBalance =
          (await usdcInstance.methods.balanceOf(pairAddress).call()) / 1000000
        if (usdcBalance > appConfig.minimumUSDCApprovalAmount) {
          responseObject.status = true
          responseObject.pairAddress = pairAddress
          responseObject.usdcBalance = usdcBalance
          return responseObject
        }
      }

      return responseObject
    } catch (err) {
      console.log('err', err)
    }

    // const contract = await new web3.eth.Contract(uniswapv3, factoryAddress);
    /* let pairAddress = await contract.methods
        .getPool(value.contractAddress, usdcAddress, 3000)
        .call();

      if (pairAddress === "0x0000000000000000000000000000000000000000") {
        return false;
      }

      pairAddress = _.toLower(pairAddress); */

    /* let variables = {
        poolid: pairAddress,
      };
      const data = await client.request(query, variables); */
  }

  public checkUniswapV2 = async (pairAddress) => {
    try {
      const responseObject = {
        status: false,
        pairAddress: '',
        usdcBalance: 0,
      }
      const variables = {
        poolid: pairAddress,
      }
      const data = await uniswapv2Client.request(v2Query, variables)
      console.log('data', data)
      const usdcAddress = _.toLower(appConfig.usdcAddress)
      let usdcReserve = 0
      usdcReserve =
        data.pair.token0.id.toLowerCase() === usdcAddress
          ? parseInt(data.pair.reserve0)
          : parseInt(data.pair.reserve1)

      if (usdcReserve > appConfig.minimumUSDCApprovalAmount) {
        responseObject.status = true
        responseObject.pairAddress = pairAddress
        responseObject.usdcBalance = usdcReserve
        return responseObject
      }
      return responseObject
    } catch (err) {
      console.log('err', err)
    }
  }

  public checkSushiswap = async (pairAddress) => {
    try {
      const responseObject = {
        status: false,
        pairAddress: '',
        usdcBalance: 0,
      }
      const variables = {
        poolid: pairAddress,
      }
      const data = await sushiswapClient.request(sushiQuery, variables)
      console.log('data', data)
      const usdcAddress = _.toLower(appConfig.usdcAddress)
      let usdcReserve = 0
      usdcReserve =
        data.pair.token0.id.toLowerCase() === usdcAddress
          ? parseInt(data.pair.reserve0)
          : parseInt(data.pair.reserve1)

      if (usdcReserve > appConfig.minimumUSDCApprovalAmount) {
        responseObject.status = true
        responseObject.pairAddress = pairAddress
        responseObject.usdcBalance = usdcReserve
        return responseObject
      }
      return responseObject
    } catch (err) {
      console.log('err', err)
    }
  }

  public getDepositedAmount = async (tokenID) => {
    const returnData = {
      astraAmount: 0,
      wethAmount: 0,
    }
    const variables = {
      tokenid: tokenID,
    }
    const data = await lpGraphQLClient.request(lpAPRQuery, variables)
    const astraAddress = _.toLower(appConfig.astraContractAddress)
    if (data.position.token0.id === astraAddress) {
      returnData.astraAmount = data.position.depositedToken0
      returnData.wethAmount = data.position.depositedToken1
    } else if (data.position.token1.id === astraAddress) {
      returnData.astraAmount = data.position.depositedToken1
      returnData.wethAmount = data.position.depositedToken0
    }
    return returnData
  }

  public static sortTokens = async () => {
    let jsonData = fs.readFileSync('public/finalTokens.json')
    jsonData = JSON.parse(jsonData)
    jsonData = _.sortBy(jsonData, ['name'])
    console.log('jsonData', jsonData)

    const jsonWriteData = JSON.stringify(jsonData)
    fs.writeFileSync('public/finalTokens1.json', jsonWriteData)
  }

  public static updateLiquidityMiningFile = async () => {
    try {
      const astraTokenDetails = await axios.get(
        `https://api.coingecko.com/api/v3/coins/astra-dao?tickers=false&community_data=true&sparkline=false`
      )
      const astraTokenCGDetails = astraTokenDetails.data
      const totalVolume =
        astraTokenCGDetails &&
        astraTokenCGDetails.market_data &&
        astraTokenCGDetails.market_data.total_volume
          ? astraTokenCGDetails.market_data.total_volume.usd
          : 0
      let tokenPrice: any =
        astraTokenCGDetails &&
        astraTokenCGDetails.market_data &&
        astraTokenCGDetails.market_data.current_price
          ? Number(astraTokenCGDetails.market_data.current_price.usd)
          : 0
      tokenPrice = Number(tokenPrice)
        .toFixed(12)
        .replace(/\.?0+$/, '')
      const query = `select * from ${databaseDetails.SCHEMA_NAME}."LP_POOLS_DETAILS_VIEW" WHERE LOWER(TOKEN0_SYMBOL) = 'astra' or LOWER(TOKEN1_SYMBOL) = 'astra' or LOWER(TOKEN0_SYMBOL) = 'astradao' or LOWER(TOKEN1_SYMBOL) = 'astradao'`
      console.log('query', query)
      const poolRecords = await snowflake.execute(query)
      let totalLiquidity = 0
      if (!_.isEmpty(poolRecords)) {
        poolRecords.forEach((element) => {
          totalLiquidity += Number(element.LIQUIDITY)
        })
      }

      const circulatingSupplyDetails = await axios.get(
        'https://r23g9ibja7.execute-api.us-east-1.amazonaws.com/main?q=circulating_supply'
      )
      const circulatingSupply = circulatingSupplyDetails.data

      let readAPRDATA = fs.readFileSync(
        `${appConfig.jsonFilepathInitials}aprdetails.json`
      )
      readAPRDATA = JSON.parse(readAPRDATA)

      let percentageOfAstraStacked: any = readAPRDATA.astraStakingAmount
        ? (readAPRDATA.astraStakingAmount / circulatingSupply) * 100
        : ''
      percentageOfAstraStacked = percentageOfAstraStacked.toFixed(2)
      const finalData = {
        totalVolume: totalVolume,
        tokenPrice: tokenPrice,
        totalLiquidity: totalLiquidity,
        averageAPY: readAPRDATA.liquidityMiningAPR,
        percentageOfAstraStacked,
      }
      const jsonData = JSON.stringify(finalData)
      fs.writeFileSync(
        `${appConfig.jsonFilepathInitials}liquidityMining.json`,
        jsonData
      )
    } catch (err) {
      console.log('err', err)
    }
  }
}
